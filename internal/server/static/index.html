<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>K8V - Kubernetes Visualizer</title>
  <!-- Fonts to match prototype -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <!-- Feather Icons for consistent icon design -->
  <script src="https://unpkg.com/feather-icons"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0a0a0a; color: #e0e0e0; overflow: hidden; }

    .container { display: flex; flex-direction: column; height: 100vh; background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%); padding: 32px; gap: 24px; }

    /* Top Navigation */
    .top-nav { background: rgba(30, 30, 30, 0.6); backdrop-filter: blur(20px); border-radius: 16px; padding: 16px 24px; display: flex; align-items: center; gap: 24px; border: 1px solid rgba(255, 255, 255, 0.06); flex-shrink: 0; }
    .logo { width: 40px; height: 40px; background: #667eea; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 18px; font-weight: 700; }
    .nav-tabs { display: flex; gap: 8px; }
    .nav-tab { padding: 10px 20px; border-radius: 10px; font-family: 'Space Grotesk', sans-serif; font-size: 14px; font-weight: 600; letter-spacing: 0.5px; text-transform: uppercase; cursor: pointer; transition: all 0.3s; border: none; background: transparent; color: #888; }
    .nav-tab.active { background: #C4F561; color: #000; letter-spacing: 1px; }
    .nav-tab:hover:not(.active) { background: rgba(255, 255, 255, 0.05); color: #fff; }
    .nav-right { margin-left: auto; display: flex; gap: 12px; align-items: center; color: #888; font-size: 12px; }

    .main-wrapper { display: flex; flex: 1; overflow: hidden; gap: 16px; }
    .sidebar { flex: 1; background: transparent; padding: 0 8px 8px 8px; overflow-y: auto; display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 16px; align-content: start; }
    .sidebar::-webkit-scrollbar { width: 8px; }
    .sidebar::-webkit-scrollbar-track { background: rgba(255,255,255,0.02); }
    .sidebar::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 4px; }

    .header { margin-bottom: 8px; grid-column: 1 / -1; }
    .header h1 { font-family: 'Inter', sans-serif; font-size: 42px; font-weight: 900; margin-bottom: 4px; color: #fff; letter-spacing: -1px; line-height: 1; }
    .header-meta { display: flex; align-items: center; gap: 12px; margin-top: 6px; font-size: 12px; color: #888; }

    /* Stats */
    .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(170px, 1fr)); gap: 10px; margin-bottom: 4px; grid-column: 1 / -1; }
    .stat-card { background: rgba(255,255,255,0.04); backdrop-filter: blur(10px); padding: 18px 20px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.08); position: relative; overflow: hidden; transition: all 0.3s cubic-bezier(0.4,0,0.2,1); }
    .stat-card::before { display: none; }
    .stat-card.highlight { background: #C4F561; border: 1px solid rgba(255,255,255,0.08); }
    .stat-card.highlight::before { content: ''; position: absolute; top:0; left:0; width:100%; height:3px; background: #C4F561; display: block; }
    .stat-card.highlight * { color: #000 !important; font-weight: 700; }
    .stat-label { font-family: 'Space Grotesk', sans-serif; font-size: 10px; color: #888; text-transform: uppercase; letter-spacing: 1.2px; font-weight: 600; margin-bottom: 6px; }
    .stat-value { font-size: 40px; font-weight: 900; color: #fff; line-height: 1; letter-spacing: -0.5px; }
    .stat-card.highlight .stat-value { color: #000; }

    /* Filters */
    .resource-filter { grid-column: 1 / -1; }
    .filter-label { grid-column: 1 / -1; font-family: 'Space Grotesk', sans-serif; font-size: 11px; color: #888; text-transform: uppercase; letter-spacing: 1.2px; font-weight: 600; margin-bottom: 4px; }
    .filter-buttons { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
    .filter-btn { background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.08); color: #888; padding: 10px 16px; border-radius: 12px; font-family: 'Space Grotesk', sans-serif; font-size: 13px; font-weight: 600; letter-spacing: 0.5px; text-transform: uppercase; cursor: pointer; transition: all 0.25s; min-width: 110px; }
    .filter-btn:hover:not(.active) { background: rgba(255,255,255,0.08); color: #fff; transform: translateY(-1px); }
    .filter-btn.active { background: #C4F561; border-color: #C4F561; color: #000; box-shadow: 0 8px 20px rgba(196,245,97,0.3); }

    /* Namespace Dropdown */
    .namespace-dropdown { position: relative; margin-top: 8px; }
    .dropdown-selected { background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.08); color: #fff; padding: 10px 16px; border-radius: 12px; font-family: 'Space Grotesk', sans-serif; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.25s; display: flex; align-items: center; justify-content: space-between; }
    .dropdown-selected::after { content: '▼'; font-size: 10px; margin-left: 8px; transition: transform 0.25s; }
    .dropdown-selected.open::after { transform: rotate(180deg); }
    .dropdown-selected:hover { background: rgba(255,255,255,0.08); border-color: rgba(255,255,255,0.12); }
    .dropdown-menu { position: absolute; top: calc(100% + 4px); left: 0; right: 0; background: rgba(20,20,30,0.98); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; padding: 8px; z-index: 1000; box-shadow: 0 8px 32px rgba(0,0,0,0.4); max-height: 300px; overflow: hidden; display: flex; flex-direction: column; }
    .dropdown-search { width: 100%; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.08); color: #fff; padding: 8px 12px; border-radius: 8px; font-family: 'Space Grotesk', sans-serif; font-size: 13px; margin-bottom: 8px; outline: none; }
    .dropdown-search:focus { background: rgba(255,255,255,0.08); border-color: #C4F561; }
    .dropdown-search::placeholder { color: #666; }
    .dropdown-options { overflow-y: auto; max-height: 240px; }
    .dropdown-options::-webkit-scrollbar { width: 6px; }
    .dropdown-options::-webkit-scrollbar-track { background: rgba(255,255,255,0.02); }
    .dropdown-options::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 3px; }
    .dropdown-option { padding: 10px 12px; border-radius: 8px; cursor: pointer; transition: all 0.2s; font-family: 'Space Grotesk', sans-serif; font-size: 13px; color: #888; }
    .dropdown-option:hover { background: rgba(255,255,255,0.08); color: #fff; }
    .dropdown-option.highlighted { background: rgba(196,245,97,0.15); color: #fff; border: 1px solid rgba(196,245,97,0.3); }
    .dropdown-option.active { background: #C4F561; color: #000; font-weight: 600; }

    /* Search Filter (Vim-style) */
    .search-filter { grid-column: 1 / -1; margin-bottom: 12px; }
    .search-trigger { background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.08); color: #666; padding: 10px 16px; border-radius: 12px; font-family: 'Space Grotesk', sans-serif; font-size: 13px; cursor: pointer; transition: all 0.25s; display: flex; align-items: center; }
    .search-trigger:hover { background: rgba(255,255,255,0.08); border-color: rgba(255,255,255,0.12); color: #888; }
    .search-placeholder kbd { background: rgba(196,245,97,0.15); color: #C4F561; padding: 2px 8px; border-radius: 4px; font-family: 'Space Grotesk', monospace; font-size: 12px; font-weight: 600; margin: 0 4px; border: 1px solid rgba(196,245,97,0.3); }
    .search-active { display: flex; align-items: center; gap: 8px; position: relative; }
    .search-input { flex: 1; background: rgba(255,255,255,0.05); border: 1px solid #C4F561; color: #fff; padding: 10px 16px; border-radius: 12px; font-family: 'Space Grotesk', sans-serif; font-size: 13px; outline: none; transition: all 0.25s; box-shadow: 0 0 0 3px rgba(196,245,97,0.1); }
    .search-input::placeholder { color: #666; }
    .search-clear { background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.08); color: #888; width: 36px; height: 36px; border-radius: 8px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.25s; flex-shrink: 0; }
    .search-clear:hover { background: rgba(244,67,54,0.2); border-color: rgba(244,67,54,0.4); color: #f44336; }

    /* Resource list */
    .resource-list { grid-column: 1 / -1; display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap: 10px; margin-bottom: 20px; }

    .resource-item { background: rgba(255,255,255,0.04); backdrop-filter: blur(10px); padding: 12px; border-radius: 12px; cursor: pointer; transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); display: flex; align-items: center; gap: 10px; border: 1px solid rgba(255,255,255,0.05); position: relative; overflow: hidden; min-height: 56px; }
    .resource-item::before { content: ''; position: absolute; left:0; top:0; bottom:0; width:3px; background: #4CAF50; opacity: 0; transition: opacity 0.3s; }
    .resource-item:hover { background: rgba(255,255,255,0.06); transform: translateX(4px) translateY(-2px); border-color: rgba(255,255,255,0.12); box-shadow: 0 8px 24px rgba(0,0,0,0.3); }
    .resource-item:hover::before { opacity: 1; }
    .resource-item.pod::before { background: #4CAF50; }
    .resource-item.deployment::before { background: #2196F3; }
    .resource-item.service::before { background: #9C27B0; }
    .resource-item.ingress::before { background: #FF9800; }
    .resource-item.replicaset::before { background: #00BCD4; }
    .resource-item.configmap::before, .resource-item.secret::before { background: #607D8B; }

    .resource-icon { width: 36px; height: 36px; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 16px; flex-shrink: 0; transition: all 0.3s; font-weight: 700; }
    .resource-item:hover .resource-icon { transform: scale(1.05); }
    .resource-icon.pod { background: rgba(76,175,80,0.2); color: #8BC34A; box-shadow: 0 4px 12px rgba(76,175,80,0.2); }
    .resource-icon.deployment { background: rgba(33,150,243,0.2); color: #03A9F4; box-shadow: 0 4px 12px rgba(33,150,243,0.2); }
    .resource-icon.service { background: rgba(156,39,176,0.2); color: #E91E63; box-shadow: 0 4px 12px rgba(156,39,176,0.2); }
    .resource-icon.ingress { background: rgba(255,152,0,0.2); color: #FFC107; box-shadow: 0 4px 12px rgba(255,152,0,0.2); }
    .resource-icon.replicaset { background: rgba(0,188,212,0.2); color: #00BCD4; box-shadow: 0 4px 12px rgba(0,188,212,0.2); }
    .resource-icon.configmap, .resource-icon.secret { background: rgba(96,125,139,0.2); color: #78909C; box-shadow: 0 4px 12px rgba(96,125,139,0.2); }

    .resource-header { display: flex; align-items: center; gap: 10px; flex: 1; min-width: 0; }
    .resource-info { flex: 1; min-width: 0; }
    .resource-name { font-size: 13px; font-weight: 700; color: #fff; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 2px; line-height: 1.2; }
    .resource-subtitle { font-size: 11px; color: #666; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .resource-status { width: 12px; height: 12px; border-radius: 50%; flex-shrink: 0; }
    .resource-status.healthy { background: #4CAF50; color: #4CAF50; box-shadow: 0 0 8px rgba(76, 175, 80, 0.6); }
    .resource-status.warning { background: #FFC107; color: #FFC107; box-shadow: 0 0 8px rgba(255, 193, 7, 0.6); }
    .resource-status.error { background: #f44336; color: #f44336; box-shadow: 0 0 12px rgba(244, 67, 54, 0.8); animation: pulse-error 2s infinite; }
    @keyframes pulse-error { 0%,100%{opacity:1; box-shadow:0 0 6px #f44336;} 50%{opacity:0.6; box-shadow:0 0 12px #f44336;} }

    /* Events drawer button */
    .events-toggle { position: fixed; bottom: 24px; right: 24px; background: #667eea; color: #fff; border: none; border-radius: 50%; width: 56px; height: 56px; display: flex; align-items: center; justify-content: center; cursor: pointer; box-shadow: 0 4px 16px rgba(102,126,234,0.4); transition: all 0.3s; z-index: 999; font-size: 24px; }
    .events-toggle:hover { transform: scale(1.1); box-shadow: 0 6px 24px rgba(102,126,234,0.6); }
    .events-badge { position: absolute; top: -4px; right: -4px; background: #f44336; color: #fff; border-radius: 12px; padding: 2px 6px; font-size: 10px; font-weight: 700; min-width: 20px; text-align: center; }

    /* Events drawer */
    #events-drawer { position: fixed; right: 0; top: 0; bottom: 0; width: 400px; background: rgba(15,15,18,0.98); backdrop-filter: blur(20px); border-left: 1px solid rgba(255,255,255,0.08); transform: translateX(100%); transition: transform 0.3s ease; overflow-y: auto; z-index: 1000; }
    #events-drawer.visible { transform: translateX(0); }
    #events-drawer::-webkit-scrollbar { width: 8px; }
    #events-drawer::-webkit-scrollbar-track { background: rgba(255,255,255,0.02); }
    #events-drawer::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 4px; }
    .events-drawer-header { background: rgba(32,32,40,0.9); padding: 20px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(255,255,255,0.08); position: sticky; top: 0; z-index: 1; }
    .events-drawer-header h2 { font-family: 'Space Grotesk', sans-serif; font-size: 18px; margin: 0; color: #C4F561; }
    .events-drawer-content { padding: 16px; }
    .event-item { padding: 12px; margin-bottom: 8px; background: rgba(255,255,255,0.03); border-radius: 8px; border-left: 3px solid rgba(255,255,255,0.1); transition: all 0.2s; }
    .event-item:hover { background: rgba(255,255,255,0.06); }
    .event-item.warning { border-left-color: #FFC107; }
    .event-item.error { border-left-color: #f44336; }
    .event-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
    .event-type { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; padding: 2px 8px; border-radius: 4px; background: rgba(255,255,255,0.1); }
    .event-type.ADDED { background: rgba(76,175,80,0.2); color: #8BC34A; }
    .event-type.MODIFIED { background: rgba(255,193,7,0.2); color: #FFC107; }
    .event-type.DELETED { background: rgba(244,67,54,0.2); color: #f44336; }
    .event-time { font-size: 11px; color: #666; }
    .event-message { font-size: 13px; color: #ccc; line-height: 1.4; }

    /* Detail panel (reuse logic) */
    #detail-panel { position: fixed; right: 0; top: 0; bottom: 0; width: 560px; background: rgba(15,15,18,0.98); border-left: 1px solid rgba(255,255,255,0.08); transform: translateX(100%); transition: transform 0.3s ease; overflow-y: auto; z-index: 1000; }
    #detail-panel.visible { transform: translateX(0); }
    .detail-header { background: rgba(32,32,40,0.9); padding: 16px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(255,255,255,0.08); }
    .panel-tabs { display: flex; background: rgba(24,24,30,0.9); border-bottom: 1px solid rgba(255,255,255,0.08); }
    .tab { padding: 12px 24px; cursor: pointer; border-bottom: 2px solid transparent; transition: all 0.2s; }
    .tab.active { border-bottom-color: #C4F561; color: #C4F561; }
    .panel-content { padding: 20px; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    .section { margin-bottom: 24px; }
    .section h3 { font-size: 16px; margin-bottom: 12px; color: #C4F561; font-family: 'Space Grotesk', sans-serif; text-transform: uppercase; letter-spacing: 1px; }
    .section h4 { font-size: 13px; margin-top: 16px; margin-bottom: 8px; color: #999; }
    .info-grid { display: grid; grid-template-columns: 120px 1fr; gap: 8px; }
    .info-label { color: #888; }
    .relationship-list { list-style: none; }
    .relationship-list li { padding: 8px; margin-bottom: 4px; background: rgba(255,255,255,0.03); border-radius: 6px; border: 1px solid rgba(255,255,255,0.06); }
    .relationship-link { color: #C4F561; text-decoration: none; cursor: pointer; }
    .relationship-link:hover { text-decoration: underline; }
    pre { background: #0b0f14; padding: 16px; border-radius: 8px; overflow-x: auto; font-size: 12px; line-height: 1.5; border: 1px solid rgba(255,255,255,0.08); }
    code { color: #81c784; }
  </style>
</head>
<body>
  <div class="container">
    <div class="top-nav">
      <div class="logo">K8</div>
      <div class="nav-tabs">
        <button class="nav-tab active" onclick="switchMainTab('dashboard')">Dashboard</button>
        <button class="nav-tab" onclick="switchMainTab('topology')">Topology</button>
      </div>
      <div class="nav-right">
        <span id="connection-status">Connecting...</span>
        <span>•</span>
        <span id="resource-count">0 resources</span>
      </div>
    </div>

    <div class="main-wrapper">
      <!-- Dashboard View -->
      <div class="sidebar" id="dashboard-view">
        <div class="header">
          <h1>Cluster Dashboard</h1>
          <div class="header-meta">
            <span>Live updates over WebSocket</span>
          </div>
        </div>

        <!-- Stats cards -->
        <div class="stats">
          <div class="stat-card highlight"><div class="stat-label">Total Resources</div><div class="stat-value" id="stat-total">0</div></div>
          <div class="stat-card"><div class="stat-label">Pods</div><div class="stat-value" id="stat-pod">0</div></div>
          <div class="stat-card"><div class="stat-label">Deployments</div><div class="stat-value" id="stat-deployment">0</div></div>
          <div class="stat-card"><div class="stat-label">ReplicaSets</div><div class="stat-value" id="stat-replicaset">0</div></div>
          <div class="stat-card"><div class="stat-label">Services</div><div class="stat-value" id="stat-service">0</div></div>
          <div class="stat-card"><div class="stat-label">Ingress</div><div class="stat-value" id="stat-ingress">0</div></div>
          <div class="stat-card"><div class="stat-label">ConfigMaps</div><div class="stat-value" id="stat-configmap">0</div></div>
          <div class="stat-card"><div class="stat-label">Secrets</div><div class="stat-value" id="stat-secret">0</div></div>
        </div>

        <!-- Namespace Filter -->
        <div class="resource-filter">
          <div class="filter-label">Namespace</div>
          <div class="namespace-dropdown">
            <div class="dropdown-selected" id="namespace-selected">All Namespaces</div>
            <div class="dropdown-menu" id="namespace-menu" style="display: none;">
              <input type="text" class="dropdown-search" id="namespace-search" placeholder="Search namespaces...">
              <div class="dropdown-options" id="namespace-options"></div>
            </div>
          </div>
        </div>

        <!-- Search Filter (Vim-style activation) -->
        <div class="search-filter" id="search-filter-container">
          <div class="filter-label">Search Resources</div>
          <div class="search-trigger" id="search-trigger">
            <i data-feather="search" style="width: 16px; height: 16px; margin-right: 8px;"></i>
            <span class="search-placeholder">Press <kbd>/</kbd> to search by name</span>
          </div>
          <div class="search-active" id="search-active" style="display: none;">
            <input
              type="text"
              class="search-input"
              id="search-input"
              placeholder="Type to filter by name... (Esc to clear)"
              autocomplete="off"
            />
            <button class="search-clear" id="search-clear" title="Clear search (Esc)">
              <i data-feather="x" style="width: 16px; height: 16px;"></i>
            </button>
          </div>
        </div>

        <!-- Resource Type Filters -->
        <div class="resource-filter">
          <div class="filter-label">Resource Type</div>
          <div class="filter-buttons" id="filters"></div>
        </div>

        <!-- Resource cards list -->
        <div class="resource-list" id="resource-list"></div>
      </div>

      <!-- Topology View -->
      <div class="sidebar" id="topology-view" style="display: none;">
        <div class="header">
          <h1>Cluster Topology</h1>
          <div class="header-meta">
            <span>Resource relationship visualization</span>
          </div>
        </div>
        <div style="grid-column: 1 / -1; padding: 40px; text-align: center; color: #888;">
          <div style="margin-bottom: 16px;"><i data-feather="git-branch" style="width: 48px; height: 48px; stroke-width: 1.5;"></i></div>
          <h2 style="color: #C4F561; margin-bottom: 8px;">Topology View Coming Soon</h2>
          <p>Interactive resource relationship diagrams will be available in a future update.</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Events toggle button -->
  <button class="events-toggle" onclick="toggleEventsDrawer()" title="View Recent Events">
    <i data-feather="activity"></i>
    <span class="events-badge" id="events-badge" style="display: none;">0</span>
  </button>

  <!-- Events drawer -->
  <div id="events-drawer">
    <div class="events-drawer-header">
      <h2>Recent Events</h2>
      <button class="nav-tab" style="background:transparent;border:1px solid rgba(255,255,255,0.1);border-radius:8px;" onclick="toggleEventsDrawer()">&times;</button>
    </div>
    <div class="events-drawer-content" id="events"></div>
  </div>

  <!-- Detail panel -->
  <div id="detail-panel">
    <div class="detail-header">
      <h2 id="detail-title">Resource Details</h2>
      <button class="nav-tab" style="background:transparent;border:1px solid rgba(255,255,255,0.1);border-radius:8px;" onclick="closeDetail()">&times;</button>
    </div>
    <div class="panel-tabs">
      <div class="tab active" onclick="switchTab('overview')">
        <i data-feather="info" style="width: 16px; height: 16px; margin-right: 6px; vertical-align: middle;"></i>
        Overview
      </div>
      <div class="tab" onclick="switchTab('yaml')">
        <i data-feather="code" style="width: 16px; height: 16px; margin-right: 6px; vertical-align: middle;"></i>
        YAML
      </div>
    </div>
    <div class="panel-content">
      <div id="overview-tab" class="tab-content active">
        <div class="section">
          <h3>Status</h3>
          <div class="info-grid" id="status-info"></div>
        </div>
        <div class="section" id="relationships-section"><h3>Relationships</h3></div>
      </div>
      <div id="yaml-tab" class="tab-content"><pre><code id="yaml-content"></code></pre></div>
    </div>
  </div>

  <script>
    // ---------- State ----------
    const resources = {}; // id -> resource
    let ws = null;
    let snapshotComplete = false;
    let snapshotCount = 0;
    let currentFilter = 'Pod';
    let currentNamespace = localStorage.getItem('k8v-namespace') || 'all'; // namespace filter
    let availableNamespaces = []; // fetched from API
    let highlightedNamespaceIndex = -1; // for keyboard navigation
    // Search filter state
    let searchQuery = ''; // Current search query
    let searchActive = false; // Whether search UI is active
    const events = []; // recent update events
    const MAX_EVENTS = 100;
    const resourceTypes = ['Pod','Deployment','ReplicaSet','Service','Ingress','ConfigMap','Secret'];

    // ---------- WebSocket ----------
    let reconnectTimeout = null;  // Track reconnect timeout
    let isManualReconnect = false;  // Flag for manual reconnections
    let wsConnectionId = 0;  // Track active connection ID

    function connect() {
      // Increment connection ID to invalidate old handlers
      const myConnectionId = ++wsConnectionId;

      console.log(`[WS] Creating connection #${myConnectionId} for namespace: ${currentNamespace}, type: ${currentFilter}`);

      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';

      // Build query parameters
      const params = [];
      if (currentNamespace !== 'all') {
        params.push(`namespace=${currentNamespace}`);
      }
      if (currentFilter !== 'all') {
        params.push(`type=${currentFilter}`);
      }
      const queryString = params.length > 0 ? '?' + params.join('&') : '';

      const wsUrl = `${protocol}//${window.location.host}/ws${queryString}`;
      ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        // Check if this is still the active connection
        if (myConnectionId !== wsConnectionId) {
          console.log(`[WS] Connection #${myConnectionId} opened but is stale (current: ${wsConnectionId}), closing`);
          ws.close();
          return;
        }
        console.log(`[WS] Connection #${myConnectionId} opened successfully`);
        document.getElementById('connection-status').textContent = `Connected (${currentNamespace === 'all' ? 'All Namespaces' : currentNamespace})`;
        snapshotComplete = false;
        snapshotCount = 0;
        isManualReconnect = false;
      };

      ws.onmessage = (event) => {
        // Check if this is still the active connection
        if (myConnectionId !== wsConnectionId) {
          console.log(`[WS] Connection #${myConnectionId} received message but is stale (current: ${wsConnectionId}), ignoring`);
          return;
        }

        const msg = JSON.parse(event.data);
        if (!snapshotComplete && msg.type === 'ADDED') {
          snapshotCount++;
          clearTimeout(window.snapshotTimer);
          window.snapshotTimer = setTimeout(() => {
            if (!snapshotComplete) {
              snapshotComplete = true;
              if (snapshotCount === 0 && currentNamespace !== 'all') {
                console.warn(`No resources found in namespace "${currentNamespace}", switching to "all"`);
                setNamespace('all');
              }
            }
          }, 900);
        }
        handleResourceEvent(msg);
      };

      ws.onerror = () => {
        if (myConnectionId !== wsConnectionId) {
          return;
        }
        document.getElementById('connection-status').textContent = 'Error';
      };

      ws.onclose = () => {
        // Check if this is still the active connection
        if (myConnectionId !== wsConnectionId) {
          console.log(`[WS] Connection #${myConnectionId} closed but is stale (current: ${wsConnectionId}), ignoring`);
          return;
        }
        console.log(`[WS] Connection #${myConnectionId} closed`);
        document.getElementById('connection-status').textContent = 'Disconnected';
        // Only auto-reconnect if this wasn't a manual disconnect
        if (!isManualReconnect) {
          console.log(`[WS] Scheduling auto-reconnect in 2s`);
          reconnectTimeout = setTimeout(connect, 2000);
        }
      };
    }

    // ---------- Filters ----------
    function renderFilters() {
      const container = document.getElementById('filters');
      container.innerHTML = '';
      for (const t of resourceTypes) {
        const btn = document.createElement('button');
        btn.className = 'filter-btn' + (currentFilter === t ? ' active' : '');
        btn.textContent = t + (t === 'Ingress' ? '' : (t.endsWith('s') ? '' : 's'));
        btn.addEventListener('click', () => setFilter(t));
        container.appendChild(btn);
      }
    }
    function setFilter(type) {
      currentFilter = type;
      reconnectWithFilter();
    }

    // ---------- Namespace Filters ----------
    async function fetchNamespaces() {
      try {
        const response = await fetch('/api/namespaces');
        const data = await response.json();
        availableNamespaces = ['all', ...data.namespaces];
        renderNamespaceFilters();
      } catch (err) {
        console.error('Failed to fetch namespaces:', err);
        availableNamespaces = ['all'];
        renderNamespaceFilters();
      }
    }

    function renderNamespaceFilters(searchTerm = '') {
      const optionsContainer = document.getElementById('namespace-options');
      const selectedDisplay = document.getElementById('namespace-selected');
      if (!optionsContainer || !selectedDisplay) return;

      // Update selected display
      selectedDisplay.textContent = currentNamespace === 'all' ? 'All Namespaces' : currentNamespace;

      // Filter namespaces based on search term
      const filtered = availableNamespaces.filter(ns => {
        const displayName = ns === 'all' ? 'All Namespaces' : ns;
        return displayName.toLowerCase().includes(searchTerm.toLowerCase());
      });

      // Store filtered list for keyboard navigation
      window.filteredNamespaces = filtered;

      // Render filtered options
      optionsContainer.innerHTML = '';
      filtered.forEach((ns, index) => {
        const option = document.createElement('div');
        let className = 'dropdown-option';
        if (currentNamespace === ns) className += ' active';
        if (index === highlightedNamespaceIndex) className += ' highlighted';
        option.className = className;
        option.textContent = ns === 'all' ? 'All Namespaces' : ns;
        option.setAttribute('data-index', index);
        option.addEventListener('click', () => {
          setNamespace(ns);
          closeNamespaceDropdown();
        });
        optionsContainer.appendChild(option);
      });
    }

    function toggleNamespaceDropdown() {
      const menu = document.getElementById('namespace-menu');
      const selected = document.getElementById('namespace-selected');
      const search = document.getElementById('namespace-search');

      if (menu.style.display === 'none') {
        menu.style.display = 'flex';
        selected.classList.add('open');
        search.value = '';
        highlightedNamespaceIndex = -1; // Reset keyboard navigation
        search.focus();
        renderNamespaceFilters('');
      } else {
        closeNamespaceDropdown();
      }
    }

    function closeNamespaceDropdown() {
      const menu = document.getElementById('namespace-menu');
      const selected = document.getElementById('namespace-selected');
      menu.style.display = 'none';
      selected.classList.remove('open');
      highlightedNamespaceIndex = -1; // Reset keyboard navigation
    }

    function filterNamespaceOptions() {
      const search = document.getElementById('namespace-search');
      highlightedNamespaceIndex = -1; // Reset on search
      renderNamespaceFilters(search.value);
    }

    function handleNamespaceKeyboard(e) {
      const menu = document.getElementById('namespace-menu');
      if (menu.style.display === 'none') return;

      const filtered = window.filteredNamespaces || [];
      if (filtered.length === 0) return;

      if (e.key === 'ArrowDown') {
        e.preventDefault();
        highlightedNamespaceIndex = Math.min(highlightedNamespaceIndex + 1, filtered.length - 1);
        renderNamespaceFilters(document.getElementById('namespace-search').value);
        scrollToHighlighted();
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        highlightedNamespaceIndex = Math.max(highlightedNamespaceIndex - 1, 0);
        renderNamespaceFilters(document.getElementById('namespace-search').value);
        scrollToHighlighted();
      } else if (e.key === 'Enter') {
        e.preventDefault();
        if (highlightedNamespaceIndex >= 0 && highlightedNamespaceIndex < filtered.length) {
          setNamespace(filtered[highlightedNamespaceIndex]);
          closeNamespaceDropdown();
        }
      } else if (e.key === 'Escape') {
        e.preventDefault();
        closeNamespaceDropdown();
      }
    }

    function scrollToHighlighted() {
      const optionsContainer = document.getElementById('namespace-options');
      const highlighted = optionsContainer.querySelector('.dropdown-option.highlighted');
      if (highlighted) {
        highlighted.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
      }
    }

    // Setup dropdown event listeners
    function setupNamespaceDropdown() {
      const selected = document.getElementById('namespace-selected');
      const search = document.getElementById('namespace-search');

      // Toggle dropdown
      selected.addEventListener('click', toggleNamespaceDropdown);

      // Filter on input
      search.addEventListener('input', filterNamespaceOptions);

      // Keyboard navigation
      search.addEventListener('keydown', handleNamespaceKeyboard);

      // Prevent dropdown from closing when clicking inside
      document.getElementById('namespace-menu').addEventListener('click', (e) => {
        e.stopPropagation();
      });

      // Close dropdown when clicking outside
      document.addEventListener('click', (e) => {
        const dropdown = document.querySelector('.namespace-dropdown');
        if (dropdown && !dropdown.contains(e.target)) {
          closeNamespaceDropdown();
        }
      });
    }

    function setNamespace(namespace) {
      currentNamespace = namespace;
      localStorage.setItem('k8v-namespace', namespace);
      reconnectWithNamespace();
    }

    function reconnectWithNamespace() {
      // Cancel any pending auto-reconnect
      if (reconnectTimeout) {
        clearTimeout(reconnectTimeout);
        reconnectTimeout = null;
      }

      // Set flag to prevent auto-reconnect when we manually close
      isManualReconnect = true;

      // Close existing connection if open
      if (ws) {
        if (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING) {
          ws.close();
        }
      }

      // Clear state
      Object.keys(resources).forEach(key => delete resources[key]);
      events.length = 0;
      snapshotComplete = false;

      // Fetch stats first (instant), then reconnect
      fetchAndDisplayStats().then(() => {
        renderResourceList();
        renderNamespaceFilters();
        connect();
      });
    }

    function reconnectWithFilter() {
      // Cancel any pending auto-reconnect
      if (reconnectTimeout) {
        clearTimeout(reconnectTimeout);
        reconnectTimeout = null;
      }

      // Set flag to prevent auto-reconnect when we manually close
      isManualReconnect = true;

      // Close existing connection if open
      if (ws) {
        if (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING) {
          ws.close();
        }
      }

      // Clear state
      Object.keys(resources).forEach(key => delete resources[key]);
      events.length = 0;
      snapshotComplete = false;

      // Fetch stats first (instant), then reconnect
      fetchAndDisplayStats().then(() => {
        renderResourceList();
        renderFilters();
        connect();
      });
    }

    // ---------- Search Filter ----------

    /**
     * Activates search mode - shows input and focuses it
     */
    function activateSearch() {
      // Don't activate if namespace dropdown is open
      const namespaceMenu = document.getElementById('namespace-menu');
      if (namespaceMenu && namespaceMenu.style.display !== 'none') {
        return;
      }

      // Don't activate if user is focused on an input
      const activeElement = document.activeElement;
      if (activeElement && (activeElement.tagName === 'TEXTAREA' ||
          activeElement.tagName === 'INPUT' ||
          activeElement.isContentEditable)) {
        return;
      }

      searchActive = true;
      document.getElementById('search-trigger').style.display = 'none';
      document.getElementById('search-active').style.display = 'flex';
      const input = document.getElementById('search-input');
      input.focus();

      // Re-render icons (for X button)
      feather.replace();
    }

    /**
     * Deactivates search mode - hides input, shows trigger
     */
    function deactivateSearch() {
      searchActive = false;
      searchQuery = '';
      document.getElementById('search-trigger').style.display = 'flex';
      document.getElementById('search-active').style.display = 'none';
      document.getElementById('search-input').value = '';

      // Re-render to show all resources
      renderResourceList();
    }

    /**
     * Clears search and exits search mode
     */
    function clearSearch() {
      deactivateSearch();
    }

    /**
     * Handles search input changes
     */
    function handleSearchInput(event) {
      searchQuery = event.target.value.toLowerCase().trim();
      renderResourceList();
    }

    /**
     * Global keyboard handler for vim-style activation
     */
    function handleGlobalKeydown(event) {
      // Ignore if user is typing in an input field
      const activeElement = document.activeElement;
      const isInputFocused = activeElement && (
        activeElement.tagName === 'INPUT' ||
        activeElement.tagName === 'TEXTAREA' ||
        activeElement.isContentEditable
      );

      // Handle '/' key for activation
      if (event.key === '/' && !isInputFocused) {
        event.preventDefault();
        activateSearch();
        return;
      }

      // Handle Escape key (priority order)
      if (event.key === 'Escape') {
        // 1. Close namespace dropdown if open
        const namespaceMenu = document.getElementById('namespace-menu');
        if (namespaceMenu && namespaceMenu.style.display !== 'none') {
          closeNamespaceDropdown();
          return;
        }

        // 2. Close detail panel if open
        const detailPanel = document.getElementById('detail-panel');
        if (detailPanel && detailPanel.classList.contains('visible')) {
          closeDetail();
          return;
        }

        // 3. Close events drawer if open
        if (eventsDrawerOpen) {
          toggleEventsDrawer();
          return;
        }

        // 4. Clear search if active
        if (searchActive) {
          clearSearch();
          return;
        }
      }
    }

    /**
     * Setup search filter event listeners
     */
    function setupSearchFilter() {
      // Click trigger to activate
      const trigger = document.getElementById('search-trigger');
      trigger.addEventListener('click', activateSearch);

      // Search input handling
      const input = document.getElementById('search-input');
      input.addEventListener('input', handleSearchInput);

      // Clear button
      const clearBtn = document.getElementById('search-clear');
      clearBtn.addEventListener('click', clearSearch);

      // Global keyboard listener
      document.addEventListener('keydown', handleGlobalKeydown);
    }

    // ---------- Stats ----------
    function updateStatCards() {
      const counts = { total: 0 };
      for (const t of resourceTypes) counts[t] = 0;
      for (const r of Object.values(resources)) { counts.total++; if (counts[r.type] !== undefined) counts[r.type]++; }
      document.getElementById('stat-total').textContent = counts.total;
      document.getElementById('stat-pod').textContent = counts['Pod'];
      document.getElementById('stat-deployment').textContent = counts['Deployment'];
      document.getElementById('stat-replicaset').textContent = counts['ReplicaSet'];
      document.getElementById('stat-service').textContent = counts['Service'];
      document.getElementById('stat-ingress').textContent = counts['Ingress'];
      document.getElementById('stat-configmap').textContent = counts['ConfigMap'];
      document.getElementById('stat-secret').textContent = counts['Secret'];
      document.getElementById('resource-count').textContent = `${counts.total} resources`;
    }

    // Fetch and display stats before connecting WebSocket
    async function fetchAndDisplayStats() {
      try {
        const nsParam = currentNamespace === 'all' ? '' : `?namespace=${currentNamespace}`;
        const response = await fetch(`/api/stats${nsParam}`);
        const counts = await response.json();

        // Update stat cards immediately
        document.getElementById('stat-total').textContent = counts.total || 0;
        document.getElementById('stat-pod').textContent = counts['Pod'] || 0;
        document.getElementById('stat-deployment').textContent = counts['Deployment'] || 0;
        document.getElementById('stat-replicaset').textContent = counts['ReplicaSet'] || 0;
        document.getElementById('stat-service').textContent = counts['Service'] || 0;
        document.getElementById('stat-ingress').textContent = counts['Ingress'] || 0;
        document.getElementById('stat-configmap').textContent = counts['ConfigMap'] || 0;
        document.getElementById('stat-secret').textContent = counts['Secret'] || 0;
        document.getElementById('resource-count').textContent = `${counts.total || 0} resources`;

        console.log('[Stats] Loaded counts:', counts);
      } catch (error) {
        console.error('[Stats] Failed to fetch stats:', error);
        // Continue anyway - WebSocket will populate stats
      }
    }

    // ---------- Resource cards ----------
    function typeToClass(t) { return t.toLowerCase(); }
    function typeShort(t) { return t.replace(/[a-z]/g, '').slice(0,2) || t[0]; }

    // Helper to create a resource DOM element
    function createResourceElement(r) {
      const item = document.createElement('div');
      item.className = `resource-item ${typeToClass(r.type)}`;
      item.setAttribute('data-resource-id', r.id);
      item.addEventListener('click', () => showResource(r.id));

      const icon = document.createElement('div');
      icon.className = `resource-icon ${typeToClass(r.type)}`;
      icon.textContent = r.type[0];

      const header = document.createElement('div');
      header.className = 'resource-header';

      const info = document.createElement('div');
      info.className = 'resource-info';

      const name = document.createElement('div');
      name.className = 'resource-name';
      name.textContent = r.name;

      const sub = document.createElement('div');
      sub.className = 'resource-subtitle';
      sub.textContent = `${r.namespace || '-'} • ${r.type}`;

      info.appendChild(name);
      info.appendChild(sub);

      const statusDot = document.createElement('div');
      statusDot.className = `resource-status ${r.health || 'unknown'}`;

      header.appendChild(info);
      header.appendChild(statusDot);

      item.appendChild(icon);
      item.appendChild(header);

      return item;
    }

    // Full render (used on initial load and filter changes)
    function renderResourceList() {
      const container = document.getElementById('resource-list');
      container.innerHTML = '';

      // Combined filter: resource type AND search query
      const list = Object.values(resources)
        .filter(r => {
          // Filter by resource type
          if (r.type !== currentFilter) return false;

          // Filter by search query (name only)
          if (searchQuery && !r.name.toLowerCase().includes(searchQuery)) {
            return false;
          }

          return true;
        })
        .sort((a,b) => a.name.localeCompare(b.name));

      // Show empty state if no resources
      if (list.length === 0) {
        const empty = document.createElement('div');
        const emptyMessage = searchQuery
          ? `No ${currentFilter}s matching "${searchQuery}"`
          : `No ${currentFilter}s found`;
        const emptyDetail = currentNamespace !== 'all'
          ? `in namespace "${currentNamespace}"`
          : 'in cluster';

        empty.innerHTML = `
          <div style="grid-column: 1 / -1; text-align: center; padding: 60px 20px; color: #666;">
            <div style="margin-bottom: 16px;"><i data-feather="inbox" style="width: 48px; height: 48px; stroke-width: 1.5;"></i></div>
            <div style="font-size: 16px; margin-bottom: 8px;">${emptyMessage}</div>
            <div style="font-size: 13px;">${emptyDetail}</div>
          </div>
        `;
        container.appendChild(empty);
        // Re-render icons after adding dynamic content
        feather.replace();
        return;
      }

      for (const r of list) {
        container.appendChild(createResourceElement(r));
      }
    }

    // Incremental update - add/update/remove single resource
    function updateResourceInList(resourceId, eventType) {
      const container = document.getElementById('resource-list');
      const existingElement = container.querySelector(`[data-resource-id="${resourceId}"]`);

      if (eventType === 'DELETED') {
        // Remove the element
        if (existingElement) {
          existingElement.remove();
        }
        return;
      }

      const resource = resources[resourceId];
      if (!resource) return;

      // Check if resource matches current filters (type AND search)
      const matchesTypeFilter = resource.type === currentFilter;
      const matchesSearchFilter = !searchQuery || resource.name.toLowerCase().includes(searchQuery);
      const matchesFilter = matchesTypeFilter && matchesSearchFilter;

      if (!matchesFilter) {
        // Resource doesn't match filter, remove it if it exists
        if (existingElement) {
          existingElement.remove();
        }
        return;
      }

      if (eventType === 'MODIFIED' && existingElement) {
        // Update existing element in place
        const newElement = createResourceElement(resource);
        existingElement.replaceWith(newElement);
      } else if (eventType === 'ADDED') {
        // Find correct position and insert
        const allVisible = Object.values(resources)
          .filter(r => {
            if (r.type !== currentFilter) return false;
            if (searchQuery && !r.name.toLowerCase().includes(searchQuery)) return false;
            return true;
          })
          .sort((a,b) => a.name.localeCompare(b.name));

        const index = allVisible.findIndex(r => r.id === resourceId);
        const newElement = createResourceElement(resource);

        if (index === allVisible.length - 1 || container.children.length === 0) {
          // Append at end
          container.appendChild(newElement);
        } else {
          // Insert before next element
          const nextResource = allVisible[index + 1];
          if (nextResource) {
            const nextElement = container.querySelector(`[data-resource-id="${nextResource.id}"]`);
            if (nextElement) {
              container.insertBefore(newElement, nextElement);
            } else {
              container.appendChild(newElement);
            }
          } else {
            container.appendChild(newElement);
          }
        }
      }
    }

    // ---------- Events ----------
    let eventsDrawerOpen = false;
    let unreadEvents = 0;

    function toggleEventsDrawer() {
      eventsDrawerOpen = !eventsDrawerOpen;
      const drawer = document.getElementById('events-drawer');
      if (eventsDrawerOpen) {
        drawer.classList.add('visible');
        unreadEvents = 0;
        updateEventsBadge();
        // Lazy render events when drawer opens
        renderEvents();
      } else {
        drawer.classList.remove('visible');
      }
    }

    function updateEventsBadge() {
      const badge = document.getElementById('events-badge');
      if (unreadEvents > 0) {
        badge.textContent = unreadEvents > 99 ? '99+' : unreadEvents;
        badge.style.display = 'block';
      } else {
        badge.style.display = 'none';
      }
    }

    function renderEvents() {
      // Only render if drawer is open (lazy loading)
      if (!eventsDrawerOpen) return;

      const el = document.getElementById('events');
      el.innerHTML = '';
      for (const e of events) {
        const item = document.createElement('div');
        item.className = 'event-item ' + (e.type === 'MODIFIED' ? 'warning' : e.type === 'DELETED' ? 'error' : '');

        const header = document.createElement('div');
        header.className = 'event-header';

        const typeSpan = document.createElement('span');
        typeSpan.className = 'event-type ' + e.type;
        typeSpan.textContent = e.type;

        const time = document.createElement('div');
        time.className = 'event-time';
        time.textContent = new Date(e.time).toLocaleTimeString();

        header.appendChild(typeSpan);
        header.appendChild(time);

        const msg = document.createElement('div');
        msg.className = 'event-message';
        msg.textContent = `${e.resource.type} › ${e.resource.namespace || 'default'} › ${e.resource.name}`;

        item.appendChild(header);
        item.appendChild(msg);
        el.appendChild(item);
      }
    }

    // ---------- Event handling ----------
    function handleResourceEvent(event) {
      const resourceId = event.resource.id;

      // Update resources state
      if (event.type === 'DELETED') {
        delete resources[resourceId];
      } else {
        resources[resourceId] = event.resource;
      }

      // Add to events log
      events.unshift({ type: event.type, resource: event.resource, time: Date.now() });
      if (events.length > MAX_EVENTS) events.pop();

      // Increment unread counter if drawer is closed and snapshot is complete
      if (!eventsDrawerOpen && snapshotComplete) {
        unreadEvents++;
        updateEventsBadge();
      }

      // NOTE: We no longer call updateStatCards() here because stats are now
      // fetched from /api/stats endpoint. Client-side resources may only contain
      // a filtered subset (e.g., only Pods) so counting them would be incorrect.

      // Use incremental update instead of full rerender
      if (snapshotComplete) {
        updateResourceInList(resourceId, event.type);
      } else {
        // During initial snapshot, still do full render periodically
        renderResourceList();
      }

      renderEvents(); // Will only render if drawer is open
    }

    // ---------- Detail panel ----------
    function showResource(resourceId) {
      const resource = resources[resourceId]; if (!resource) return;
      document.getElementById('detail-title').textContent = `${resource.type}: ${resource.name}`;
      const statusInfo = document.getElementById('status-info');
      statusInfo.innerHTML = `
        <div class="info-label">Namespace:</div><div>${resource.namespace || '-'}</div>
        <div class="info-label">Phase:</div><div>${resource.status.phase || '-'}</div>
        <div class="info-label">Ready:</div><div>${resource.status.ready || '-'}</div>
        <div class="info-label">Health:</div><div><span class="resource-status ${resource.health}" style="display:inline-block"></span> ${resource.health}</div>
        ${resource.status.message ? `<div class="info-label">Message:</div><div>${resource.status.message}</div>` : ''}`;
      const relationshipsSection = document.getElementById('relationships-section');
      let relationshipsHTML = '<h3>Relationships</h3>';
      const relationshipTypes = [
        { key: 'ownedBy', label: 'Owned By' }, { key: 'owns', label: 'Owns' },
        { key: 'dependsOn', label: 'Depends On' }, { key: 'usedBy', label: 'Used By' },
        { key: 'exposes', label: 'Exposes' }, { key: 'exposedBy', label: 'Exposed By' },
        { key: 'routesTo', label: 'Routes To' }, { key: 'routedBy', label: 'Routed By' }
      ];
      relationshipTypes.forEach(({ key, label }) => {
        const refs = resource.relationships[key];
        if (refs && refs.length > 0) {
          relationshipsHTML += `<h4>${label}</h4><ul class="relationship-list">${refs.map(ref => `<li><a class="relationship-link" onclick="showResource('${ref.id}')">${ref.type}: ${ref.name}</a></li>`).join('')}</ul>`;
        }
      });
      relationshipsSection.innerHTML = relationshipsHTML;
      document.getElementById('yaml-content').textContent = resource.yaml || 'No YAML available';
      document.getElementById('detail-panel').classList.add('visible');
    }
    function closeDetail() { document.getElementById('detail-panel').classList.remove('visible'); }
    function switchTab(tabName) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      event.target.classList.add('active');
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
      document.getElementById(`${tabName}-tab`).classList.add('active');
    }

    // ---------- Main tab switching ----------
    function switchMainTab(tabName) {
      // Update active state on nav tabs
      document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
      event.target.classList.add('active');

      // Show/hide views
      if (tabName === 'dashboard') {
        document.getElementById('dashboard-view').style.display = 'grid';
        document.getElementById('topology-view').style.display = 'none';
      } else if (tabName === 'topology') {
        document.getElementById('dashboard-view').style.display = 'none';
        document.getElementById('topology-view').style.display = 'grid';
      }
    }

    // ---------- Init ----------
    async function init() {
      renderFilters();
      renderResourceList();
      setupNamespaceDropdown();  // Setup dropdown event listeners
      setupSearchFilter();  // Setup search filter event listeners
      fetchNamespaces();  // Fetch namespaces first

      // Fetch and display stats (instant)
      await fetchAndDisplayStats();

      // Then connect WebSocket (lazy)
      setTimeout(() => {
        connect();
      }, 100);
    }

    // Start initialization
    init();

    // Render Feather icons
    feather.replace();
  </script>
</body>
</html>
